<!DOCTYPE html>
<html lang="en">
	<head>
		<title>my - collada</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			#button {
				position: fixed;
				font-family: Calibri;
				bottom: 20px;
				right: 20px;
				padding: 8px;
				color: #ffffff;
				background-color: rgb(0, 58, 153);
				border-color: #000000;
				border-style: solid ;
				border-width: 1px;
				opacity: 0.6;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
			}

			#button:hover {
				cursor: pointer;
				opacity: 1;
			}

			#firstButton {
				position: fixed;
				font-family: Calibri;
				bottom: 20px;
				right: 100px;
				padding: 8px;
				color: #ffffff;
				background-color: rgb(0, 58, 153);
				border-color: #000000;
				border-style: solid ;
				border-width: 1px;
				opacity: 0.6;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
			}

			#firstButton:hover {
				cursor: pointer;
				opacity: 1;
			}

			#secondButton {
				position: fixed;
				font-family: Calibri;
				bottom: 20px;
				right: 150px;
				padding: 8px;
				color: #ffffff;
				background-color: rgb(0, 58, 153);
				border-color: #000000;
				border-style: solid ;
				border-width: 1px;
				opacity: 0.6;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
			}

			#secondButton:hover {
				cursor: pointer;
				opacity: 1;
			}

			#thirdButton {
				position: fixed;
				font-family: Calibri;
				bottom: 20px;
				right: 200px;
				padding: 8px;
				color: #ffffff;
				background-color: rgb(0, 58, 153);
				border-color: #000000;
				border-style: solid ;
				border-width: 1px;
				opacity: 0.6;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
			}

			#thirdButton:hover {
				cursor: pointer;
				opacity: 1;
			}
			body {
				background:#fff;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
			a {
				color: #ffffff;
			}
		</style>
	</head>
	<body>

		<div id="canvas"></div>

		<script src="build/three.js"></script>
		<script src="js/Detector.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/ColladaLoader.js"></script>

		<script src="js/loaders/TTFLoader.js"></script>
		<script src="js/libs/opentype.min.js"></script>

		<script src="js/libs/screenfull.js"></script>
		<script src="js/libs/Tween.js"></script>

		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FXAAShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/OutlinePass.js"></script>
		<script src="js/postprocessing/SSAARenderPass.js"></script>

		<script type="x-shader/x-fragment" id="PCSS">
				#define LIGHT_WORLD_SIZE 0.005
				#define LIGHT_FRUSTUM_WIDTH 3.75
				#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
				#define NEAR_PLANE 2.5
				#define NUM_SAMPLES 17
				#define NUM_RINGS 11
				#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES
				#define PCF_NUM_SAMPLES NUM_SAMPLES
				vec2 poissonDisk[NUM_SAMPLES];
				void initPoissonSamples( const in vec2 randomSeed ) {
					float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
					float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );
					// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
					float angle = rand( randomSeed ) * PI2;
					float radius = INV_NUM_SAMPLES;
					float radiusStep = radius;
					for( int i = 0; i < NUM_SAMPLES; i ++ ) {
						poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );
						radius += radiusStep;
						angle += ANGLE_STEP;
					}
				}
				float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
					return (zReceiver - zBlocker) / zBlocker;
				}
				float findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {
					// This uses similar triangles to compute what
					// area of the shadow map we should search
					float searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;
					float blockerDepthSum = 0.0;
					int numBlockers = 0;
					for( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {
						float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
						if ( shadowMapDepth < zReceiver ) {
							blockerDepthSum += shadowMapDepth;
							numBlockers ++;
						}
					}
					if( numBlockers == 0 ) return -1.0;
					return blockerDepthSum / float( numBlockers );
				}
				float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {
					float sum = 0.0;
					for( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {
						float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
						if( zReceiver <= depth ) sum += 1.0;
					}
					for( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {
						float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
						if( zReceiver <= depth ) sum += 1.0;
					}
					return sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );
				}
				float PCSS ( sampler2D shadowMap, vec4 coords ) {
					vec2 uv = coords.xy;
					float zReceiver = coords.z; // Assumed to be eye-space z in this code
					initPoissonSamples( uv );
					// STEP 1: blocker search
					float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );
					//There are no occluders so early out (this saves filtering)
					if( avgBlockerDepth == -1.0 ) return 1.0;
					// STEP 2: penumbra size
					float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );
					float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;
					// STEP 3: filtering
					//return avgBlockerDepth;
					return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );
				}
		</script>

		<script type="x-shader/x-fragment" id="PCSSGetShadow">
			return PCSS( shadowMap, shadowCoord );
		</script>

		<script>

			var canvas, camera, scene, renderer, controls, dae, dae1, loader;
			var hemiLight, dirLight, hemiLightHelper, dirLightHeper;
			var ssaaRenderPass;
			var myTimer, particleLight;

            var composer, outlinePass, effectFXAA;

            var showPanel = [];
            var IDText = ["", "Положение рельсовых нитей\n        в плане и профиле", "Компьютер", "Камера обзорного\nвидеонаблюдения", "test"];
            var fontInfo = null;
            var currentItem = 1;
            var useItem = false;
            var objectPlane;
            var text, linesShift;

            var obj3d = new THREE.Object3D();
            var groupAll = new THREE.Object3D();

            var raycaster = new THREE.Raycaster();

            var mouse = new THREE.Vector2();
            var selectedObjects = [];
			var idRemove;

            var paramAA = {
                sampleLevel: 0
            };

            var fps,nn=0,finFps=1;
            var lastLoop = new Date;
            var switchState = false;
            var switchState1 = false;

            var isMouseMove = false;

            var loadingScreen, loadingManager, RESOURCES_LOADED, backgroundScene, backgroundCamera;

            var xTarget=0; xTargetAim=0;
            var yTarget=0; yTargetAim=0;
            var zTarget=0; zTargetAim=0;
            var tweenDuration=0;

            var myResetSwitch = false;

            function checkFpsMy() {
                var thisLoop = new Date;
                fps = 1000 / (thisLoop - lastLoop);
                lastLoop = thisLoop;
                nn = nn + 1;
                finFps = finFps + fps;
                if (nn===100)
				{
                    finFps = finFps/nn;
				    //document.getElementsByTagName('myfps')[0].innerHTML = Math.round(finFps);
                    if ( finFps<30 && paramAA.sampleLevel>0 )paramAA.sampleLevel = paramAA.sampleLevel-1;
                    if ( finFps>60 && paramAA.sampleLevel<2 )paramAA.sampleLevel = paramAA.sampleLevel+1;
                    //document.getElementsByTagName('para')[0].innerHTML = paramAA.sampleLevel;
				    nn=0;
                }
            }

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            canvas = document.getElementById( 'canvas' );

            start();
            init();
			animate();

            function start() {

                // An object to hold all the things needed for our loading screen

                loadingScreen = {
                    scene: new THREE.Scene(),
                    camera: new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1,120)
                };
                loadingScreen.camera.position.set( 0, 0, 5 );

                var loader1 = new THREE.ColladaLoader();
                loader1.load( 'models/logo.dae', function ( collada ) {
                        dae1 = collada.scene;
                        dae1.traverse( function(child) {
                            if (child instanceof THREE.Mesh) {
                                //child.material.side = THREE.DoubleSide;
                                child.material = new THREE.MeshPhongMaterial({color: 0x01376d});
                                //child.material.reflectivity = 0.8;
                                child.material.shininess = 180;
                                child.castShadow = false;
                                child.receiveShadow = false;
                            }
                        });
                        dae1.scale.x = dae1.scale.y = dae1.scale.z = 0.013;
                        dae1.updateMatrix();
                        loadingScreen.scene.add( dae1 );
                    },
                    function ( xhr ) {
                        //console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    }
                );

                particleLight = new THREE.PointLight( 0x95c7ff, 2, 100 );
                particleLight.position.set( 3, 12, 5 );
                loadingScreen.scene.add( particleLight );

                var hemiLight1 = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
                hemiLight1.color.setHSL( 0.6, 1, 0.6 );
                hemiLight1.groundColor.setHSL( 0.095, 1, 0.75 );
                hemiLight1.position.set( 0, 0, 0 );
                loadingScreen.scene.add( hemiLight1 );

                // Load the background texture

                var textureBack = THREE.ImageUtils.loadTexture( 'models/tex/back.png' );
                var backgroundMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2, 0),
                    new THREE.MeshBasicMaterial({
                        map: textureBack
                    }));
                backgroundMesh .material.depthTest = false;
                backgroundMesh .material.depthWrite = false;

                // Create your background scene

                loadingManager = null;
                RESOURCES_LOADED = false;
                backgroundScene = new THREE.Scene();
                backgroundCamera = new THREE.Camera();
                backgroundScene .add( backgroundCamera );
                backgroundScene .add( backgroundMesh );

            }

            function init() {

			scene = new THREE.Scene();
			scene.anisotropy = 15;
			//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.set( -2, 0.6, 2.4 );

			// Create a loading manager to set RESOURCES_LOADED when appropriate.
            // Pass loadingManager to all resource loaders.

            loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(item, loaded, total){
                //console.log(item, loaded, total);
            };
            loadingManager.onLoad = function(){
                //console.log("loaded all resources");
                RESOURCES_LOADED = true;
            };

            // ShadowMap

            var shader = THREE.ShaderChunk.shadowmap_pars_fragment;
            shader = shader.replace(
                '#ifdef USE_SHADOWMAP',
                '#ifdef USE_SHADOWMAP' +
                document.getElementById( 'PCSS' ).textContent
            );
            shader = shader.replace(
                '#if defined( SHADOWMAP_TYPE_PCF )',
                document.getElementById( 'PCSSGetShadow' ).textContent +
                '#if defined( SHADOWMAP_TYPE_PCF )'
            );
            THREE.ShaderChunk.shadowmap_pars_fragment = shader;

            // Renderer

            renderer = new THREE.WebGLRenderer({ antialias: true });
            //renderer.sortObjects = false;
            //renderer.setClearColor( scene.fog.color );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.renderReverseSided = false;
            renderer.shadowMap.renderSingleSided = false;
            renderer.shadowMap.Type = THREE.PCFSoftShadowMap;
            document.body.appendChild( renderer.domElement );

			// OrbitControls

			controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.reset();
                controls.minPolarAngle = Math.PI / 12.3;
                controls.maxPolarAngle = Math.PI / 2.3;
                controls.minDistance = 2.4;
                controls.maxDistance = 5;
                controls.min = 0;
                controls.target.y = 0.6;
                controls.autoRotate = true;
                controls.update();

			// LIGHTS

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.3 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 0, 0 );
			scene.add( hemiLight );

			dirLight = new THREE.DirectionalLight( 0xdfebff, 1.15 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -10, 10.75, 10 );
			//dirLight.position.multiplyScalar( 5 );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 512*8;
			dirLight.shadow.mapSize.height = 512*8;
			dirLight.shadow.camera.far = 30;
			dirLight.shadow.bias = -0.0003;
			scene.add( dirLight );

			// Texture Load

            var textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = true;
            var texRefl = textureLoader.load( 'models/tex/sky2.jpg' );
            texRefl.mapping = THREE.SphericalReflectionMapping;
            var texBolt = textureLoader.load( 'models/tex/bolt.jpg' );
            texBolt.mapping = THREE.SphericalReflectionMapping;
            var textureSky = textureLoader.load( 'models/tex/sky2x2.jpg' );
            var nasipMap = textureLoader.load( 'models/tex/Gravel.jpg' );
            var nasipMapB = textureLoader.load( 'models/tex/GravelB.jpg' );
            textureSky.minFilter = THREE.NearestFilter;
            textureSky.magFilter = THREE.NearestFilter;
            textureSky.anisotropy = 15;
            textureSky.generateMipmaps = true;

			// Sky

			var skyGeo = new THREE.SphereGeometry( 100, 32, 32 );
			var material = new THREE.MeshBasicMaterial({map: textureSky});
			var sky = new THREE.Mesh(skyGeo, material);
				sky.castShadow = false;
				sky.receiveShadow = false;
				sky.material.side = THREE.BackSide;
 			scene.add( sky );

            var loaderTTF = new THREE.TTFLoader();
			loaderTTF.load( 'fonts/NeoSansPro-Regular.ttf', function ( json ) {
				fontInfo = new THREE.Font( json );
                for (var i = 0; i < IDText.length; i++) {
                    showPanelRun(i);
                }
			} );
                    // COLLADA Loader

			loader = new THREE.ColladaLoader();
			//loader.options.convertUpAxis = true;
			loader.load( 'models/rpi_web.dae', function ( collada ) {
			dae = collada.scene;
			dae.traverse( function(child) {
				if (child instanceof THREE.Mesh) {
                    child.material.side = THREE.DoubleSide;
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.drawMode.anisotropy = 15;
                    //alert(child.id);
                    //console.log(child.id);

                    if ((child.material.name !== "kepi") && (child.material.name !== "nasip") &&
						(child.material.name !== "Casual_18b_Map") && (child.material.name !== "spala") &&
						(child.material.name !== "scan_disc")) {
                        child.material.envMap = texBolt;
                        child.material.reflectivity = 0.2;
                        //child.material.combine = THREE.Multiply;
                        child.material.shininess = 100;
	                    child.material.metalness = 1;
					}

                    if ((child.material.name === "nasip")) {
                        child.material = new THREE.MeshPhongMaterial( { map: nasipMap, bumpMap: nasipMapB } );
                        nasipMap.wrapS = nasipMap.wrapT = THREE.RepeatWrapping;
                        nasipMap.repeat.set(4, 4);
                        nasipMapB.wrapS = nasipMapB.wrapT = THREE.RepeatWrapping;
                        nasipMapB.repeat.set(4, 4);
                        child.material.bumpScale = 12;
                        child.material.shininess = 0;
                        child.material.metalness = 0;
                        child.material.side = THREE.FrontSide;
                        child.drawMode.anisotropy = 15;
                        child.castShadow = false;
                        child.receiveShadow = true;
                    }

                    if (child.material.name === "izmer") {
                        child.material.envMap = texRefl;
                        child.material.reflectivity = 0;
                        child.material.shininess = 0;
                        child.material.metalness = 0;
                        child.castShadow = false;
                        child.receiveShadow = false;
                        child.material.side = THREE.FrontSide;
                    }

                    if (child.material.name === "Casual_18b_Map") {
                        child.material.reflectivity = 0;
                        child.material.shininess = 0;
                        child.material.metalness = 0;
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.material.side = THREE.FrontSide;
                    }

                    if ((child.material.name === "scan_disc")) {
                        child.material = new THREE.MeshLambertMaterial({color: 0x0030ff, transparent: true, opacity: 0.2});
                        child.material.side = THREE.DoubleSide;
						child.castShadow = false;
                        child.receiveShadow = false;
                        //child.visible = false;
                    }

                    if ((child.material.name === "video")) {
                        child.material = new THREE.MeshLambertMaterial({color: 0xffffff, transparent: true, opacity: 0.4});
                        child.material.side = THREE.DoubleSide;
                        child.castShadow = false;
                        child.receiveShadow = true;
                        //child.visible = false;
                    }

                    if ((child.material.name === "screen")) {
                        child.material = new THREE.MeshPhongMaterial({color: 0x0e0e0e});
                        child.material.side = THREE.DoubleSide;
                        child.material.envMap = texBolt;
                        child.material.reflectivity = 0.8;
                        child.material.shininess = 80;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }

                    if ((child.material.name === "red")) {
                        child.material = new THREE.MeshPhongMaterial({color: 0xff0f00});
                        child.material.side = THREE.DoubleSide;
                        child.material.envMap = texRefl;
                        child.material.reflectivity = 0.2;
                        child.material.shininess = 100;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }

                    if ((child.material.name === "ref")) {
                        child.material = new THREE.MeshPhongMaterial({color: 0xa3a3a3});
                        child.material.envMap = texBolt;
                        child.material.reflectivity = 0.95;
                        child.material.side = THREE.DoubleSide;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }

                    if ((child.material.name === "ref1")) {
                        child.material = new THREE.MeshPhongMaterial({color: 0xa3a3a3});
                        child.material.envMap = texRefl;
                        child.material.reflectivity = 0.95;
                        child.material.side = THREE.DoubleSide;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }

                }
            });
				groupAll.add( dae );
				//dae.scale.x = dae.scale.y = dae.scale.z = 0.01;
				dae.updateMatrix();
				myReset();
				Buttons();
				CheckInfo();
				loadingManager.onLoad();
				},

            function ( xhr ) {
//               if (xhr.loaded / xhr.total * 100 >= 99) { loadingManager.onLoad(); };
                //console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            }
            );
			scene.add( groupAll );


			// postprocessing

			composer = new THREE.EffectComposer( renderer );
			ssaaRenderPass = new THREE.SSAARenderPass( scene, camera );
			ssaaRenderPass.unbiased = true;
            composer.addPass( ssaaRenderPass );

			outlinePass = new THREE.OutlinePass( new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
			outlinePass.edgeStrength = 3.0;
			outlinePass.edgeGlow = 0.6;
			outlinePass.edgeThickness = 1.8;
			outlinePass.pulsePeriod = 0;
			outlinePass.visibleEdgeColor = new THREE.Color( 0.6, 0.8, 1 );
			outlinePass.hiddenEdgeColor  = new THREE.Color( 0.2, 0.4, 1 );

			outlinePass.usePatternTexture = false;
			composer.addPass( outlinePass );

                var onLoad = function ( texture ) {
                    outlinePass.patternTexture = texture;
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                };
                var loader_t = new THREE.TextureLoader();

                // load a resource
                loader_t.load(
                    // resource URL
                    'models/tex/back.png',
                    // Function when resource is loaded
                    onLoad
                );

			effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );
			effectFXAA.renderToScreen = true;
			composer.addPass( effectFXAA );

			window.addEventListener( 'resize', onWindowResize, false );
            document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'mousedown', onMouseDown, false );
			document.addEventListener( 'mouseup', onMouseUp, false );
			document.addEventListener( 'mousemove', onMouseMove, false );

            }

            function onMouseDown() {

                isMouseMove = false;

            }

            function onMouseUp(event) {

                if ( event.target.id ==='button' ) {
                    return;
                }

                //canvas.style.cursor = 'pointer';
                controls.autoRotate = false;
                clearTimeout(myTimer);
                myTimer = setTimeout(myReset, 25000);

                if ( isMouseMove === true ) {
                    return;
                }

                if ( idRemove === "block_4_5_6_sel" ) {myOne()}

                if ( idRemove === "comp_sel" ) {myTwo()}

                if ( idRemove === "block_8_camera_sel" ) {
                    useItem = true;
                    myThree();
                    groupAll.traverse( function ( object ) { if(object.name === "viewCam") object.visible = !object.visible; } );
                }

                if ( idRemove === "block_9_sel" ) {
                    for (var i = 0; i < IDText.length; i++) {
                        if (showPanel[i].scale.x > 0) {
                            new TWEEN.Tween(showPanel[i].scale).to({
                                x: 0.0001,
                                y: 0.0001
                            }, 600)
                                .easing(TWEEN.Easing.Quartic.Out).start();
                        }
                    }

                    groupAll.traverse( function ( object ) { if(object.name === "scanDisc") object.visible = !object.visible; } );
                }

                if ( idRemove === "" ) {
                    groupAll.traverse( function ( object ) { if(object.name === "scanDisc") if (object.visible = true) {object.visible = false}; } );
                }

            }

            function onMouseMove( event ) {

                isMouseMove = true;
                clearTimeout(myTimer);
                myTimer = setTimeout(myReset, 25000);

                var x, y;

                if ( event.changedTouches ) {
                    x = event.changedTouches[ 0 ].pageX;
                    y = event.changedTouches[ 0 ].pageY;
                } else {
                    x = event.clientX;
                    y = event.clientY;
                }
                mouse.x = ( x / window.innerWidth ) * 2 - 1;
                mouse.y = - ( y / window.innerHeight ) * 2 + 1;

                checkIntersection();
            }

            function addSelectedObject(object) {
                selectedObjects = [];
                selectedObjects.push(object);
            }

            function checkIntersection() {

                raycaster.setFromCamera(mouse, camera);

                var intersects = raycaster.intersectObjects([groupAll], true);

                if (intersects.length > 0) {
                    selectedObjects = [];
                    groupAll.traverse(
                        function (object) {
                            if (object.id === intersects[0].object.id) {

                                selectedObject = object;

                                if ((object.parent.name.slice(-4) === "_sel"))
                                {
                                    selectedObject = object.parent;
                                }
								if ((object.parent.parent.name.slice(-4) === "_sel"))
								{
									selectedObject = object.parent.parent;
								}
								if ((object.parent.parent.parent.name.slice(-4) === "_sel"))
								{
									selectedObject = object.parent.parent.parent;
								}

                                if ((selectedObject.name.slice(-4) !== "_sel")) {
                                    selectedObjects = [];
                                }
                                else {
                                    //groupAll.traverse( function ( object ) { if( object.name === selectedObject.name ) object.material.color.setHex( 0xffff00 );});
                                    addSelectedObject(selectedObject);
                                }

                                //selectedObject.maskBufferMaterial.color.setHex( 0xffff00 );

                                //addSelectedObject(selectedObject);
                                idRemove = selectedObject.name;
                                //document.getElementsByTagName('objSelect')[0].innerHTML = selectedObject.name;
                            }
                        }
                    );
                    outlinePass.selectedObjects = selectedObjects;
                }
                else {
                    outlinePass.selectedObjects = [];
                }
            }

            function onKeyDown (event) {

			switch ( event.keyCode ) {
				case 72: // h
					hemiLight.visible = !hemiLight.visible;
					hemiLightHelper.visible = !hemiLightHelper.visible;
					break;
				case 68: // d
					dirLight.visible = !dirLight.visible;
					dirLightHeper.visible = !dirLightHeper.visible;
					break;
                case 70: // f
                    screenfull.toggle();
                    break;
                case 82: // r
                    myReset();
					break;
				}
			}

			function onWindowResize() {

				var width = window.innerWidth;
				var height = window.innerHeight;
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );
				var pixelRatio = renderer.getPixelRatio();
				var newWidth  = Math.floor( width / pixelRatio ) || 1;
				var newHeight = Math.floor( height / pixelRatio ) || 1;
				composer.setSize( newWidth, newHeight );
				effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight );

			}

            function Buttons() {

                var button = document.createElement('div');
                button.id = 'button';
                button.textContent = 'Reset';
                button.addEventListener('click', myReset, false);
                document.body.appendChild(button);

                var button1 = document.createElement('div');
                button1.id = 'firstButton';
                button1.textContent = '1';
                button1.addEventListener('click', myOne, false);
                document.body.appendChild(button1);

                var button2 = document.createElement('div');
                button2.id = 'secondButton';
                button2.textContent = '2';
                button2.addEventListener('click', myTwo, false);
                document.body.appendChild(button2);

                var button3 = document.createElement('div');
                button3.id = 'thirdButton';
                button3.textContent = '3';
                button3.addEventListener('click', myThree, false);
                document.body.appendChild(button3);

            }

            function CheckInfo() {

                var fpsMy = document.createElement('myfps');
                fpsMy.style.position = 'absolute';
                fpsMy.style.width = 100;
                fpsMy.style.height = 100;
                fpsMy.style.top = 30 + 'px';
                fpsMy.style.left = 10 + 'px';
                document.body.appendChild(fpsMy);

                var pararam = document.createElement('para');
                pararam.style.position = 'absolute';
                pararam.style.width = 100;
                pararam.style.height = 100;
                pararam.style.top = 50 + 'px';
                pararam.style.left = 10 + 'px';
                document.body.appendChild(pararam);

                var objSel = document.createElement('objSelect');
                objSel.style.position = 'absolute';
                objSel.style.width = 100;
                objSel.style.height = 100;
                objSel.style.top = 70 + 'px';
                objSel.style.left = 10 + 'px';
                document.body.appendChild(objSel);

            }

            function myReset () {

				if (myResetSwitch === true ) {
                    panCam(-2, 0, 2.4, 0, 0.6, 0, 1000);
                    controls.autoRotate = true;
                    controls.update();
                }
				else {myResetSwitch = true}

                switchState = false;
                switchState1 = false;

                SwitchOff();

                for (var i = 0; i < IDText.length; i++) {
                    if (showPanel[i].scale.x > 0) {
                        new TWEEN.Tween(showPanel[i].scale).to({
                            x: 0.0001,
                            y: 0.0001
                        }, 600)
                            .easing(TWEEN.Easing.Quartic.Out).start();
                    }
                }
            }

			function ShowMe(numm) {

                for (var i = 0; i < IDText.length; i++) {
                    if ((showPanel[i].scale.x > 0.01) && (i !== numm)) {
                        new TWEEN.Tween(showPanel[i].scale).to({
                            x: 0.0001,
                            y: 0.0001
                        }, 600)
                            .easing(TWEEN.Easing.Quartic.Out).start();
                    }
                }

				if ( showPanel[numm].scale.x < 1 ) {
					new TWEEN.Tween(showPanel[numm].scale).to({
						x: 1,
						y: 1 }, 600)
						.easing(TWEEN.Easing.Quartic.Out).start();
				}
                if ( showPanel[numm].scale.x === 1 ) {
                    new TWEEN.Tween(showPanel[numm].scale).to({
                        x: 0.0001,
                        y: 0.0001 }, 600)
                        .easing(TWEEN.Easing.Quartic.Out).start();
                }
			}

			function SwitchOff() {
				groupAll.traverse(function (object) {
					if (object.name === "viewCam") object.visible = false;
				});
				groupAll.traverse(function (object) {
					if (object.name === "scanDisc") object.visible = false;
				});
			}

            function myOne () {

                SwitchOff();
                panCam(-0.4,0.4,2,-0.2,0.5,0,1000);
                showPanel[1].position.set(-0.5,0.7,0.8);
                ShowMe(1);
            }

            function myTwo () {

                SwitchOff();
                panCam(0.5,2,0,0,0,0,1000);
                showPanel[2].position.set(0,0.9,0.19);
                showPanel[2].rotation.z = Math.PI / 2;
                showPanel[2].rotation.x = -Math.PI / 2;
                ShowMe(2);
            }

            function myThree () {

				if (useItem === false) {
                    groupAll.traverse(function (object) {
                        if (object.name === "viewCam") object.visible = !object.visible;
                    });
                }
                useItem = false;
				panCam(1,0.5,2,-3,0.8,0.5,1000);
                showPanel[3].position.set(-0.5,1.2,1.2);
                showPanel[3].rotation.y = Math.PI / 2;
                ShowMe(3);
            }

            function panCam(xTarget,yTarget,zTarget,xTargetAim,yTargetAim,zTargetAim,tweenDuration){

                TWEEN.removeAll();

                var camNewPosition= { x : xTarget, y : yTarget, z : zTarget };
                var targetNewPos = { x : xTargetAim, y : yTargetAim, z : zTargetAim };

                var camTween = new TWEEN.Tween(camera.position).to(camNewPosition, tweenDuration).easing(TWEEN.Easing.Quadratic.InOut).start();
                var targetTween = new TWEEN.Tween(controls.target).to(targetNewPos, tweenDuration).easing(TWEEN.Easing.Quadratic.InOut).start();
            }

            function showPanelRun(coun) {

                showPanel[coun] = new THREE.Object3D();

                //alert(coun);

				var textMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});

				var textGeo = new THREE.TextBufferGeometry(IDText[coun], {

					font: fontInfo,
                    size: 0.06,
                    curveSegments: 4,
					height: 0

				});

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				textInfo = new THREE.Mesh(textGeo, textMaterial);

                textInfo.position.x = 0.02;
                textInfo.position.y = textGeo.boundingBox.max.y -textGeo.boundingBox.min.y-0.07+0.04;
                textInfo.position.z = 0;

                showPanel[coun].add(textInfo);

				xx = (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x)+0.04;
				yy = (textGeo.boundingBox.max.y - textGeo.boundingBox.min.y)+0.04;

                var infograph = new THREE.MeshLambertMaterial({color: 0x000000, emissive: 0x011248, transparent: true, opacity: 0.9});
                infograph.side = THREE.DoubleSide;

                objectPlane = new THREE.Mesh( new THREE.PlaneGeometry( xx, yy, 0, 0 ), infograph);
                objectPlane.position.x = xx/2;
                objectPlane.position.y = yy/2;
                objectPlane.position.z = -0.001;
                showPanel[coun].add( objectPlane );

                showPanel[coun].position.y = 0.5;
                showPanel[coun].position.z = 0.5;
                showPanel[coun].scale.x = 0.0001;
                showPanel[coun].scale.y = 0.0001;

                scene.add(showPanel[coun]);

			}

            function animate() {

				checkFpsMy();
				requestAnimationFrame(animate);

            // This block runs while resources are loading.

            if( RESOURCES_LOADED === false ){

                // FlyingLight

/*
                var timer = Date.now() * 0.0006;
                particleLight.position.x = Math.sin( timer * 7 ) * 3*0.4;
                particleLight.position.y = Math.cos( timer * 5 ) * 4*0.4;
                particleLight.position.z = Math.cos( timer * 3 ) * 3*0.4;
*/

                renderer.autoClear = false;
                renderer.clear();
                renderer.render(backgroundScene, backgroundCamera );
                renderer.render(loadingScreen.scene, loadingScreen.camera);
                return; // Stop the function here.
            }
                //document.getElementsByTagName('objSelect')[0].innerHTML = IDText[2];

			TWEEN.update();

            if (controls.target.y < 0.4) controls.target.y = 0.4;
            if (controls.target.y > 1.2) controls.target.y = 1.2;
            if (controls.target.x > 0.6) controls.target.x = 0.6;
            if (controls.target.x < -0.6) controls.target.x = -0.6;
            if (controls.target.z > 0.6) controls.target.z = 0.6;
            if (controls.target.z < -0.6) controls.target.z = -0.6;

            controls.update();

			if (ssaaRenderPass.sampleLevel !== paramAA.sampleLevel) ssaaRenderPass.sampleLevel = paramAA.sampleLevel;

            composer.render();
		}

		</script>
	</body>
</html>
